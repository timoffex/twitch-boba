import { app, BrowserWindow, ipcMain, shell } from 'electron';
import fs from 'fs';
import * as http from 'http';
import path from 'path';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  ipcMain.on('do-twitch-auth', () => {
    const TWITCH_AUTHORIZE_URI = 'https://id.twitch.tv/oauth2/authorize';
    const OAUTH_CLIENT_ID = 'bz6gycujcnbnw2vvm615omfg7ptgjm';
    const OAUTH_REDIRECT_URI = 'http://localhost:8080/twitch-oauth'
    shell.openExternal(
      TWITCH_AUTHORIZE_URI
      + `?client_id=${OAUTH_CLIENT_ID}`
      + `&redirect_uri=${OAUTH_REDIRECT_URI}`
      + '&response_type=token'
      + `&scope=${encodeURIComponent('chat:read')}`);
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

function respondWithFile(
  res: http.ServerResponse,
  contentType: string,
  fileName: string
): void {
  res.writeHead(200, { "Content-Type": contentType });
  fs
    .createReadStream(path.join(__dirname, fileName))
    .pipe(res, { end: true });
}

function respondNotFound(res: http.ServerResponse): void {
  res.writeHead(404).end('Not found');
}

function handlePublicFileRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse
): void {
  if (!Boolean(req.url?.startsWith('/public/'))) {
    respondNotFound(res);
    return;
  }

  const fileName = req.url.slice(1);

  let mimeType: string | undefined;
  switch (path.extname(fileName)) {
    case '.html': mimeType = 'text/html'; break;
    case '.js': mimeType = 'text/javascript'; break;
    case '.css': mimeType = 'text/css'; break;
  }

  if (!mimeType) {
    respondNotFound(res);
    return;
  }

  respondWithFile(res, mimeType, fileName);
}

function handleOverlayRequest(
  _req: http.IncomingMessage,
  res: http.ServerResponse
): void {
  console.log('Got overlay request');
  respondWithFile(res, 'text/html', 'public/overlay/video_overlay.html');
}

function handleTwitchOauthRequest(
  _req: http.IncomingMessage,
  res: http.ServerResponse
): void {
  respondWithFile(res, 'text/html', 'public/twitch-oauth/index.html');
}

function handleRequest(req: http.IncomingMessage, res: http.ServerResponse): void {
  console.log(`Got request at ${req.url}`);

  if (req.url?.startsWith('/overlay')) {
    handleOverlayRequest(req, res);
  } else if (req.url === '/twitch-oauth') {
    handleTwitchOauthRequest(req, res);
  } else if (req.url?.startsWith('/public/')) {
    handlePublicFileRequest(req, res);
  } else {
    respondNotFound(res);
  }
}


const server = http.createServer(handleRequest);
server.listen(8080);
